diff --git a/quickjs-libc.c b/quickjs-libc.c
index a6e8f36..09c2601 100644
--- a/quickjs-libc.c
+++ b/quickjs-libc.c
@@ -34,37 +34,53 @@
 #include <signal.h>
 #include <limits.h>
 #include <sys/stat.h>
+
 #if defined(_WIN32)
-  #include <windows.h>
-  #include <conio.h>
-  #include <io.h>
-  #include <fcntl.h>
-  #include <sys/types.h>
-  #include <sys/stat.h>
-  #include <sys/utime.h>
-  #include "win/dirent.h"
-  #ifndef PATH_MAX
-    #define PATH_MAX MAX_PATH
-  #endif
-  #define popen _popen
-  #define pclose _pclose
+    #include <windows.h>
+    #include <conio.h>
+    #include <io.h>
+    #include <fcntl.h>
+    #include <sys/types.h>
+    #include <sys/stat.h>
+    #include <sys/utime.h>
+
+    #if __has_include(<dirent.h>)
+        #include <dirent.h>
+    #else
+        #include "win/dirent.h"
+    #endif
+
+    #if __has_include(<unistd.h>)
+        #include <unistd.h>
+    #endif
+
+    #ifndef PATH_MAX
+        #define PATH_MAX MAX_PATH
+    #endif
+
+    #define popen _popen
+    #define pclose _pclose
 #else
-  #include <dirent.h>
-  #include <unistd.h>
-  #include <sys/time.h>
-#include <dlfcn.h>
-#include <termios.h>
-#include <sys/ioctl.h>
-#include <sys/wait.h>
-
-#if defined(__APPLE__)
-typedef sig_t sighandler_t;
-#if !defined(environ)
-#include <crt_externs.h>
-#define environ (*_NSGetEnviron())
-#endif
-#endif /* __APPLE__ */
-
+    #include <sys/time.h>
+    #include <dlfcn.h>
+    #include <termios.h>
+    #include <sys/ioctl.h>
+    #include <sys/wait.h>
+    #include <dirent.h>
+    #include <unistd.h>
+
+    #if defined(__APPLE__)
+        typedef sig_t sighandler_t;
+        #if !defined(environ)
+            #include <crt_externs.h>
+            #define environ (*_NSGetEnviron())
+        #endif
+    #endif /* __APPLE__ */
+
+    #if defined(__FreeBSD__)
+        typedef sig_t sighandler_t;
+        __BEGIN_DECLS
+        extern char **environ;
+        __END_DECLS
+    #endif  /* __FreeBSD__ */
 #endif
 
 #if !defined(_WIN32)
@@ -142,6 +158,18 @@ typedef struct JSThreadState {
 static uint64_t os_pending_signals;
 static int (*os_poll_func)(JSContext *ctx);
 
+#if defined(_WIN32)
+static char *realpath(const char *path, char *buf)
+{
+    if (!_fullpath(buf, path, PATH_MAX)) {
+        errno = ENOENT;
+        return NULL;
+    } else {
+        return buf;
+    }
+}
+#endif
+
 static void js_std_dbuf_init(JSContext *ctx, DynBuf *s)
 {
     dbuf_init2(s, JS_GetRuntime(ctx), (DynBufReallocFunc *)js_realloc_rt);
@@ -540,7 +568,7 @@ int js_module_set_import_meta(JSContext *ctx, JSValueConst func_val,
         return -1;
     if (!strchr(module_name, ':')) {
         strcpy(buf, "file://");
-#if !defined(_WIN32)
+// #if !defined(_WIN32)
         /* realpath() cannot be used with modules compiled with qjsc
            because the corresponding module source code is not
            necessarily present */
@@ -552,7 +580,7 @@ int js_module_set_import_meta(JSContext *ctx, JSValueConst func_val,
                 return -1;
             }
         } else
-#endif
+// #endif
         {
             pstrcat(buf, sizeof(buf), module_name);
         }
@@ -2658,18 +2686,6 @@ static JSValue js_os_sleep(JSContext *ctx, JSValueConst this_val,
     return JS_NewInt32(ctx, ret);
 }
 
-#if defined(_WIN32)
-static char *realpath(const char *path, char *buf)
-{
-    if (!_fullpath(buf, path, PATH_MAX)) {
-        errno = ENOENT;
-        return NULL;
-    } else {
-        return buf;
-    }
-}
-#endif
-
 /* return [path, errorcode] */
 static JSValue js_os_realpath(JSContext *ctx, JSValueConst this_val,
                               int argc, JSValueConst *argv)
diff --git a/quickjs.c b/quickjs.c
index eb6642b..a1e86fb 100644
--- a/quickjs.c
+++ b/quickjs.c
@@ -285,6 +285,9 @@ struct JSRuntime {
     JSHostPromiseRejectionTracker *host_promise_rejection_tracker;
     void *host_promise_rejection_tracker_opaque;
 
+    JSHostPromiseRejectionTracker *host_unhandled_promise_rejection_tracker;
+    void *host_unhandled_promise_rejection_tracker_opaque;
+
     struct list_head job_list; /* list of JSJobEntry.link */
 
     JSModuleNormalizeFunc *module_normalize_func;
@@ -7979,6 +7982,8 @@ static JSValue JS_GetPropertyValue(JSContext *ctx, JSValueConst this_obj,
         uint32_t idx, len;
         /* fast path for array access */
         p = JS_VALUE_GET_OBJ(this_obj);
+        if (unlikely(!p->fast_array))
+            goto slow_path;
         idx = JS_VALUE_GET_INT(prop);
         len = (uint32_t)p->u.array.count;
         if (unlikely(idx >= len))
@@ -46739,6 +46744,7 @@ typedef struct JSPromiseData {
     struct list_head promise_reactions[2];
     BOOL is_handled; /* Note: only useful to debug */
     JSValue promise_result;
+    JSContext * ctx;
 } JSPromiseData;
 
 typedef struct JSPromiseFunctionDataResolved {
@@ -46819,6 +46825,14 @@ void JS_SetHostPromiseRejectionTracker(JSRuntime *rt,
     rt->host_promise_rejection_tracker_opaque = opaque;
 }
 
+void JS_SetHostUnhandledPromiseRejectionTracker(JSRuntime *rt,
+                                       JSHostPromiseRejectionTracker *cb,
+                                       void *opaque)
+{
+    rt->host_unhandled_promise_rejection_tracker = cb;
+    rt->host_unhandled_promise_rejection_tracker_opaque = opaque;
+}
+
 static void fulfill_or_reject_promise(JSContext *ctx, JSValueConst promise,
                                       JSValueConst value, BOOL is_reject)
 {
@@ -46829,6 +46843,7 @@ static void fulfill_or_reject_promise(JSContext *ctx, JSValueConst promise,
 
     if (!s || s->promise_state != JS_PROMISE_PENDING)
         return; /* should never happen */
+
     set_value(ctx, &s->promise_result, JS_DupValue(ctx, value));
     s->promise_state = JS_PROMISE_FULFILLED + is_reject;
 #ifdef DUMP_PROMISE
@@ -47023,6 +47038,14 @@ static void js_promise_finalizer(JSRuntime *rt, JSValue val)
 
     if (!s)
         return;
+
+    if (s->promise_state == JS_PROMISE_REJECTED && !s->is_handled) {
+        if (rt->host_unhandled_promise_rejection_tracker) {
+            rt->host_unhandled_promise_rejection_tracker(s->ctx, val, s->promise_result, FALSE,
+                                                         rt->host_unhandled_promise_rejection_tracker_opaque);
+        }
+    }
+
     for(i = 0; i < 2; i++) {
         list_for_each_safe(el, el1, &s->promise_reactions[i]) {
             JSPromiseReactionData *rd =
@@ -47073,6 +47096,7 @@ static JSValue js_promise_constructor(JSContext *ctx, JSValueConst new_target,
     s = js_mallocz(ctx, sizeof(*s));
     if (!s)
         goto fail;
+    s->ctx = ctx;
     s->promise_state = JS_PROMISE_PENDING;
     s->is_handled = FALSE;
     for(i = 0; i < 2; i++)
diff --git a/quickjs.h b/quickjs.h
index 1193a88..6a59807 100644
--- a/quickjs.h
+++ b/quickjs.h
@@ -1005,6 +1005,7 @@ typedef void JSHostPromiseRejectionTracker(JSContext *ctx, JSValueConst promise,
                                            JSValueConst reason,
                                            JS_BOOL is_handled, void *opaque);
 void JS_SetHostPromiseRejectionTracker(JSRuntime *rt, JSHostPromiseRejectionTracker *cb, void *opaque);
+void JS_SetHostUnhandledPromiseRejectionTracker(JSRuntime *rt, JSHostPromiseRejectionTracker *cb, void *opaque);
 
 /* return != 0 if the JS code needs to be interrupted */
 typedef int JSInterruptHandler(JSRuntime *rt, void *opaque);
